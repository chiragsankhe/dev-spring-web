## spring Boot rest API Security 

+ Spring Security is a powerful and highly customizable authentication and access-control framework for Java applications, particularly those built with Spring Framework.
+ It is widely used in `enterprise applications ` to `secure web`  and` RESTful APIs`.

### üîê Core Features of Spring Security:
+ `Authentication`  ‚Äì Verifies who the user is (e.g., username/password, OAuth, JWT).

+ `Authorization` ‚Äì Determines what the user is allowed to do (roles, permissions).

+ `Protection against attacks`  ‚Äì Such as CSRF, session fixation, clickjacking.

+ `Password hashing` ‚Äì BCrypt, SCrypt, Argon2 support.

+ `Security for REST APIs` ‚Äì Token-based authentication (like JWT).

+ `Customizable filters`  ‚Äì You can plug in your own security logic easily.

### üß± Basic Components:
+ `SecurityFilterChain` : Intercepts HTTP requests and applies security rules.

+ `UserDetailsService` : Loads user-specific data.

+ `PasswordEncoder`: For encoding and validating passwords.

+ `AuthenticationManager`: Processes authentication requests.

+ `HttpSecurity` : Fluent API to configure web-based security.

###  enable Spring Security in a Spring Boot project, follow these steps:


#### ‚úÖ 1. Add Spring Security Dependency
If you're using Maven, add this to your pom.xml:

```sh
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
```

‚úÖ 2. Run the Application
Just by adding the dependency, Spring Security gets auto-configured.

+ Default behavior:

+ Secures all endpoints.

+ Exposes a form login page.

Uses an autogenerated password printed in the console.
```sh
Using generated security password: a1b2c3d4...
```
#### ‚úÖ 3. Override Default Security (Optional)
You can customize the security by creating a configuration class:
```sh
@Configuration
@EnableWebSecurity
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(auth -> auth
                .anyRequest().authenticated()
            )
            .formLogin(); // enables form login

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User
            .withUsername("chirag")
            .password(passwordEncoder().encode("1234"))
            .roles("USER")
            .build();

        return new InMemoryUserDetailsManager(user);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```
####‚úÖ 4. Test the Security
Visit any endpoint like `http://localhost:8080/` in your browser.

You'll be prompted with a login page.

Use the username/password you've configured.


## spring security configration 

+ Spring Security, the default `username`  is `user`, and the password is randomly generated unless you override them.

+ You can override the default username and password in two main ways:

### ‚úÖ 1. Using application.properties or application.yml
+ This is the simplest way if you're not using a custom `UserDetailsService`.

##### üëâ application.properties:
```sh
spring.security.user.name=chirag
spring.security.user.password=1234
spring.security.user.roles=USER
```
### ‚úÖ 2. Using Java Configuration (UserDetailsService)
If you want full control, override via Java code:
```sh
@Bean
public UserDetailsService userDetailsService() {
    UserDetails user = User.withUsername("chirag")
        .password(passwordEncoder().encode("1234"))
        .roles("USER")
        .build();

    return new InMemoryUserDetailsManager(user);
}
```
üìå This overrides the default user account and ignores values from application.properties.

### ‚úÖ You Can Still Log the Password (Optional)
If you want to log or generate a password dynamically at runtime:

```sh
String rawPassword = UUID.randomUUID().toString().substring(0, 8);
System.out.println("Generated Password: " + rawPassword);
```
But for consistent login during development, manual setting is preferred.


## DemoSecurityconfig
```sh
package com.luv2code.springboot.cruddemo.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;

@Configuration
public class DemoSecurityConfig {

    @Bean
    public InMemoryUserDetailsManager userDetailsManager()
    {
      UserDetails chirag = User.builder()
              .username("chirag")
              .password("{noop}chirag692001")
              .roles("EMPLOYEE")
              .build();

        UserDetails prachi = User.builder()
                .username("prachi")
                .password("{noop}prachi1741997")
                .roles("EMPLOYEE", "MANAGER")
                .build();


        UserDetails pranjal = User.builder()
                .username("pranjal")
                .password("{noop}pranjal79195")
                .roles("EMPLOYEE","MANAGER","ADMIN")
                .build();


        return new InMemoryUserDetailsManager(chirag , prachi , pranjal);
    }
}

```

### ‚úÖ Purpose of Your DemoSecurityConfig Class
+ This class is a Spring Security configuration that sets up `in-memory`  authentication.
+ You define a list of users who can authenticate with `usernames` ,` passwords` , and `roles`.

### üîç What You Did Line-by-Line:
```sh
@Configuration
public class DemoSecurityConfig {
```
+ This class is a configuration class.
+ Spring will detect it and use it to configure security.

```sh
@Bean
public InMemoryUserDetailsManager userDetailsManager() {
```
+ You're defining a bean that returns an `InMemoryUserDetailsManager`, which holds users in memory ‚Äî no database needed.

#### üë§ User Definitions:
```sh
UserDetails chirag = User.builder()
    .username("chirag")
    .password("{noop}chirag692001")
    .roles("EMPLOYEE")
    .build();
```
+ This creates a user named `chirag`  with password `chirag6920011`, assigned the role `EMPLOYEE`.

+ {noop} means the password is `plain text` (not encrypted). Useful for testing only.

You did the same for:

+ prachi with roles `EMPLOYEE` ,` MANAGER` 

+ pranjal with roles `EMPLOYEE` ,` MANAGER` ,` ADMIN` 

‚úÖ Final Return:
```sh
return new InMemoryUserDetailsManager(chirag , prachi , pranjal);
```
You return a manager with all these users loaded.



